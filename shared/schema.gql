scalar Time
scalar Upload

directive @client on QUERY | FIELD
directive @trackOperation(eventName: String!) on FIELD_DEFINITION
directive @trackAppOperation(eventName: String!) on FIELD_DEFINITION
directive @trackAppUseOperation on FIELD_DEFINITION
directive @trackToolOperation(eventName: String!) on FIELD_DEFINITION
directive @trackToolUseOperation on FIELD_DEFINITION
directive @canAccessInvitation on FIELD_DEFINITION
directive @canManageApp on FIELD_DEFINITION

###############################################################################
### Auth
###############################################################################

directive @hasRole(role: AuthRole!) on FIELD_DEFINITION
directive @isMe on FIELD_DEFINITION

enum AuthRole {
  AUTHENTICATED
  ADMIN
  USER
}

###############################################################################
### Auth end
###############################################################################

###############################################################################
### User management
###############################################################################

enum Role {
  ADMIN
  USER
}

type OrganizationMembership {
  organization: Organization!
  role: Role!
  user: User!
}

type User {
  id: ID!
  fullName: String!
  memberships: [OrganizationMembership!]! @isMe
  email: String!
}

type UserNotFound {
  id: ID!
}

type Query {
  me: User! @hasRole(role: AUTHENTICATED)
}

###############################################################################
### End of user management
###############################################################################

###############################################################################
### Organization management
###############################################################################

type Organization {
  id: ID!
  name: String!
  slug: String!
  apps: [App!]!
  members: [OrganizationMembership!]! @hasRole(role: USER)
  pendingInvitations: [OrganizationInvitation!]! @hasRole(role: ADMIN)
  createdAt: Time!
  paymentAccount: PaymentAccount
}

type OrganizationInvitation {
  id: ID!
  email: String!
  organizationName: String!
  invitedAt: Time!
  role: Role!
}

type InvalidEmail {
  email: String!
}

type OrganizationMemberExists {
  email: String!
}

input NewOrganization {
  name: String!
  slug: String
}

input OrganizationMemberEditRoleInput {
  userId: ID!
  role: Role!
}

type OrganizationNotFound {
  id: ID!
  slug: String!
}

type OrganizationRenameFailure {
  result: String!
}

type OrganizationSlugOccupied {
  slug: String!
}

type OrganizationSlugInvalid {
  slug: String!
}

union OrganizationRenameResult =
    Organization
  | OrganizationNotFound
  | OrganizationRenameFailure

union OrganizationQueryResult = Organization | OrganizationNotFound
union OrganizationCreateResult =
    Organization
  | OrganizationSlugOccupied
  | OrganizationSlugInvalid
union OrganizationMemberEditRoleResult =
    Organization
  | OrganizationNotFound
  | UserNotFound

extend type Query {
  organization(organizationSlug: String!): OrganizationQueryResult!
    @hasRole(role: USER)
  organizationInvitation(invitationId: ID!): OrganizationInvitationQueryResult
    @canAccessInvitation
}

type Mutation {
  organizationCreate(input: NewOrganization!): OrganizationCreateResult!
    @hasRole(role: AUTHENTICATED)
    @trackOperation(eventName: "Organization Create")
  organizationRename(
    organizationId: ID!
    name: String!
  ): OrganizationRenameResult! @hasRole(role: ADMIN)
  organizationMemberEditRole(
    organizationId: ID!
    input: OrganizationMemberEditRoleInput!
  ): OrganizationMemberEditRoleResult! @hasRole(role: ADMIN)
}
###############################################################################
### End of organization management
###############################################################################

###############################################################################
### Auth0 invitation management
###############################################################################

input Auth0WhiteLabelInvitationInput {
  email: String!
  organizationID: ID!
}

type Auth0WhiteLabelInvitation {
  email: String!

  invitedAt: Time!
}
extend type Mutation {
  Auth0WhiteLabelInvitationCreate(
    input: Auth0WhiteLabelInvitationInput
  ): Auth0WhiteLabelInvitation!
}
###############################################################################
### End of Auth0Organization management
###############################################################################

###############################################################################
### Organization invitation management
###############################################################################

input OrganizationInvitationInput {
  role: Role!
  email: String!
}

type OrganizationInvitationNotFound {
  id: ID!
}

type OrganizationInvitationExists {
  email: String!
}

union OrganizationInvitationQueryResult =
    OrganizationInvitation
  | OrganizationNotFound
  | OrganizationInvitationNotFound

union OrganizationInvitationCreateResult =
    OrganizationInvitation
  | OrganizationNotFound
  | InvalidEmail
  | OrganizationMemberExists
  | OrganizationInvitationExists

union OrganizationInvitationAcceptResult = Organization | OrganizationNotFound

type OrganizationInvitationDeleted {
  id: ID!
}

union OrganizationInvitationDeleteResult =
    OrganizationInvitationDeleted
  | OrganizationNotFound
  | OrganizationInvitationNotFound

extend type Mutation {
  organizationInvitationCreate(
    organizationId: ID!
    input: OrganizationInvitationInput
  ): OrganizationInvitationCreateResult!
    @hasRole(role: ADMIN)
    @trackOperation(eventName: "Organization invitation create")
  organizationInvitationAccept(
    invitationId: ID!
  ): OrganizationInvitationAcceptResult
    @canAccessInvitation
    @trackOperation(eventName: "Organization invitation accept")
  organizationInvitationDelete(
    invitationId: ID!
  ): OrganizationInvitationDeleteResult @hasRole(role: ADMIN)
}

###############################################################################
### End of organization invitation management
###############################################################################

###############################################################################
### Tool management
###############################################################################

type Tool {
  id: ID!
  name: String!
  description: String
  user: User!
  publicUrl: String
  sharedUrl: String
  privateUrl: String
  createdAt: Time!
}

type PublicTool {
  id: ID!
  developer: User!
  name: String!
  description: String
  pictureUrl: String
  publicUrl: String!
  createdAt: Time!
}

extend type Query {
  publicTools: [PublicTool!]
  tool(id: ID!): Tool!
  tools: [Tool!]! @hasRole(role: AUTHENTICATED)
}

input NewTool {
  userId: ID!
  manifest: String!
}

type ToolDeleteSuccess {
  result: String!
}

type ToolDeleteFailure {
  result: String!
}

union ToolDeleteResult = ToolDeleteSuccess | ToolDeleteFailure

extend type Mutation {
  toolCreate(input: NewTool!): Tool!
    @trackToolOperation(eventName: "App Create")
  toolPublish(id: ID!): Tool! @trackToolOperation(eventName: "App Publish")
  toolUnpublish(id: ID!): Tool! @trackToolOperation(eventName: "App Unpublish")
  toolDelete(id: ID!): ToolDeleteResult!
    @trackToolOperation(eventName: "App Delete")
}

###############################################################################
### End of tool management
###############################################################################

###############################################################################
### App management
###############################################################################

enum AppDeploymentStatus {
  PENDING
  RUNNING
  ERROR
  STOPPED
  UNKNOWN
}

type AppDeploymentVersion {
  id: ID!
  status: AppDeploymentStatus!
  proxyURL: String
}

type AppDeployment {
  id: ID!
  name: String!
  current: AppDeploymentVersion
}

type AppVersion {
  id: ID!
  version: String!
  message: String!
}

input AppVersionInput {
  version: String
  message: String
}

type App {
  id: ID!
  slug: String!
  displayName: String!
  description: String!
  createdBy: User!
  createdAt: Time!
  pictureUrl: String
  defaultDeployment: AppDeployment
}

type AppVersionUploadURL {
  url: String!
}

input AppCreateInfo {
  appSlug: String!
  displayName: String!
  description: String!
}

input AppDeployInput {
  appRelativePath: String
  secrets: [AppSecret!]
}

type AppBuildMessageEvent {
  message: String!
}

type AppBuildErrorEvent {
  message: String!
}

type AppDeploymentStatusEvent {
  status: AppDeploymentStatus
}

union AppDeployEvent =
    AppBuildMessageEvent
  | AppDeploymentStatusEvent
  | AppBuildErrorEvent

input AppDeployLogsInput {
  organizationSlug: String!
  appSlug: String!
}

type AppDeployLogEntry {
  timestamp: Time!
  text: String!
}

type AppDeleted {
  appSlug: String!
  organizationSlug: String
}

input AppDeleteInput {
  appSlug: String!
  organizationSlug: String!
}

extend type Query {
  app(organizationSlug: String!, appSlug: String!): App @hasRole(role: USER)
}

extend type Mutation {
  appCreate(organizationSlug: String!, appData: AppCreateInfo!): App!
    @hasRole(role: USER)
    @trackAppOperation(eventName: "App Create")
  appVersionCreate(appID: ID!, input: AppVersionInput): AppVersion!
    @canManageApp
    @trackAppOperation(eventName: "App Version Create")
  appVersionUploadURL(appVersionID: ID!): AppVersionUploadURL!
    @canManageApp
    @trackAppOperation(eventName: "App Version Upload URL")
  appDeploy(appVersionID: ID!, input: AppDeployInput): AppDeploymentVersion!
    @canManageApp
    @trackAppOperation(eventName: "App Deploy")
  appDelete(input: AppDeleteInput!): AppDeleted! @canManageApp
}

extend type Subscription {
  appDeployEvents(appDeploymentVersionID: ID!): AppDeployEvent!
  appDeployLogs(input: AppDeployLogsInput!): AppDeployLogEntry!
}

###############################################################################
### End of App management
###############################################################################

###############################################################################
### Subscriptions
###############################################################################

directive @canAccessSubscriptionOffer on FIELD_DEFINITION
directive @canAccessSubscription on FIELD_DEFINITION
directive @canManageSubscription on FIELD_DEFINITION

enum SubscriptionOfferStatus {
  ACCEPTED
  REJECTED
  PENDING
}

enum AppSubscriptionStatus {
  ACTIVE
  WITHDRAWN
}

type AppSubscription {
  id: ID!
  app: App!
  inboundOrganization: Organization!
  outboundOrganization: Organization!
  status: AppSubscriptionStatus!
}

type SubscriptionOffer {
  id: ID!
  email: String!
  app: App!
  offeringOrganization: Organization!
  status: SubscriptionOfferStatus!
  message: String!
}

input SubscriptionOfferInput {
  email: String!
  appSlug: String!
  message: String
}

type SubscriptionOfferNotFound {
  id: ID!
}

type SubscriptionOfferInvalidStatus {
  id: ID!
}

type AppSubscriptionNotFound {
  id: ID!
}

type AppSubscriptionInvalidStatus {
  id: ID!
}

union SubscriptionOfferCreateResult = SubscriptionOffer | InvalidEmail

union SubscriptionOfferResult = SubscriptionOffer | SubscriptionOfferNotFound

union SubscriptionOfferAcceptResult =
    AppSubscription
  | SubscriptionOfferNotFound
  | SubscriptionOfferInvalidStatus

union AppSubscriptionCancelResult =
    AppSubscription
  | AppSubscriptionNotFound
  | AppSubscriptionInvalidStatus

extend type Organization {
  outboundSubscriptionOffers: [SubscriptionOffer!]! @hasRole(role: ADMIN)
  outboundSubscriptions: [AppSubscription!]! @hasRole(role: ADMIN)
}

extend type App {
  subscription: AppSubscription
}

extend type Query {
  subscription(subscriptionId: ID!): AppSubscription! @canAccessSubscription
  subscriptionOffer(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
}

extend type Mutation {
  subscriptionOfferCreate(
    input: SubscriptionOfferInput!
    organizationId: ID!
  ): SubscriptionOfferCreateResult! @hasRole(role: ADMIN)
  subscriptionOfferAccept(
    subscriptionOfferId: ID!
    organizationId: ID!
  ): SubscriptionOfferAcceptResult! @canAccessSubscriptionOffer
  subscriptionOfferReject(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
  subscriptionOfferWithdraw(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
  subscriptionCancel(subscriptionId: ID!): AppSubscriptionCancelResult!
    @canManageSubscription
}

###############################################################################
### End of Subscriptions
###############################################################################

###############################################################################
### Job management
###############################################################################

type Job {
  id: ID!
  status: String
  proxyUrl: String
  user: User!
  createdAt: Time!
}

type JobNotFound {
  id: ID!
}

type JobHeartbeatSuccess {
  id: ID!
}

type JobHeartbeatFailure {
  result: String!
}

union JobHeartbeatResult =
    JobHeartbeatSuccess
  | JobHeartbeatFailure
  | JobNotFound

type StopJobPayload {
  message: String!
}

enum ToolHashType {
  public
  shared
  private
}

extend type Query {
  job(toolHash: ID!, hashType: ToolHashType!): Job
  jobsByTool(id: ID!): [Job!]!
}

extend type Mutation {
  jobStart(toolHash: ID!, hashType: ToolHashType!): Job! @trackToolUseOperation
  jobStop(id: ID!): StopJobPayload!
  jobHeartbeat(id: ID!): JobHeartbeatResult!
}

###############################################################################
### End of job management
###############################################################################

###############################################################################
### Custom tool development
###############################################################################

interface ElementGraphParent {
  id: ID!
}

type ElementGraphContext {
  parent: ElementGraphParent
  affectedBy: [Element]!
  affects: [Element]!
}

interface Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type Container implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type SliderElement implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: Float!
  minValue: Float!
  maxValue: Float!
}

type HTMLElement implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  html: String!
}

type Button implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: String!
}

type TextField implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: String!
}

type NumberField implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: Float!
}

type ElementList implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type ElementSelect implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  selectedOption: Element!
}

type ToolSession {
  id: ID!
  name: String!
  allElements: [Element!]!
  isActive: Boolean!
  clientID: String!
  title: String!
}

input ElementInput {
  elementID: ID!
  textValue: String
  numberValue: Float
  htmlValue: String
  sliderValue: Float
}

input ElementSelectInput {
  selectElementID: ID!
  selectedOptionID: ID!
}

input ListElementInput {
  listElementID: ID!
}

extend type Query {
  toolSession(id: ID!): ToolSession!
}

extend type Mutation {
  toolSessionCreate: ToolSession!
  elementUpdate(
    toolSessionId: ID!
    clientId: ID!
    element: ElementInput!
  ): Element!
  elementTrigger(
    toolSessionId: ID!
    clientId: ID!
    actionElementId: ID!
  ): Element!
  elementSelectionUpdate(
    clientId: ID!
    elementSelection: ElementSelectInput!
  ): Element!
  listElementAdd(clientId: ID!, listElement: ListElementInput): Element!
  listElementRemove(clientId: ID!, listItemID: ID!): Element!
}

type ToolSessionElementAdded {
  element: Element!
}

type ToolSessionElementRemoved {
  element: Element!
}

type ToolSessionElementUpdated {
  element: Element!
}

type ToolSessionActionTriggered {
  element: Button!
}

union ToolSessionEvent =
    ToolSessionElementAdded
  | ToolSessionElementRemoved
  | ToolSessionElementUpdated
  | ToolSessionActionTriggered

type Subscription {
  toolSessionEvent(toolSessionId: ID!, clientId: ID!): ToolSessionEvent!
}

###############################################################################
### End of custom tool development
###############################################################################

###############################################################################
### CLI Push command
###############################################################################

type buildConfiguration {
  buildId: ID!
}

type BuildEventSuccess {
  result: String!
}

type BuildEventFailure {
  result: String!
}

type BuildEventInfo {
  result: String!
}

union BuildEvent = BuildEventSuccess | BuildEventFailure | BuildEventInfo

input AppSecret {
  name: String!
  base64Value: String!
}

input BuildPushInput {
  secrets: [AppSecret!]
}

extend type Mutation {
  buildPush(file: Upload!, id: ID!, input: BuildPushInput): buildConfiguration!
    @trackOperation(eventName: "App Push")
}

extend type Subscription {
  buildEvents(buildId: ID!, appPath: String): BuildEvent!
}

extend type Subscription {
  deployEvents(toolID: ID!): BuildEvent!
}

###############################################################################
### End of CLI Push command
###############################################################################

###############################################################################
### CLI Logs command
###############################################################################

type LogMessage {
  time: Time!
  message: String!
}

extend type Subscription {
  logs(appId: ID!): LogMessage!
}

###############################################################################
### End of CLI Logs command
###############################################################################

###############################################################################
## Paginiation
###############################################################################

type PageInfo {
  startCursor: ID
  endCursor: ID
  hasNextPage: Boolean!
}

###############################################################################
## End of Pagination
###############################################################################

###############################################################################
## Collections
###############################################################################

directive @canAccessCollection on FIELD_DEFINITION

type Collection {
  id: ID!
  key: ID!

  collections(after: ID, first: Int): CollectionConnection!
}

type CollectionEdge {
  node: Collection!
  cursor: ID!
}

type CollectionConnection {
  edges: [CollectionEdge!]!
  pageInfo: PageInfo!
}

type CollectionNotFound {
  id: ID!
}

union CollectionCreateResult = Collection | CollectionNotFound

extend type Mutation {
  # idempotent
  collectionCreate(
    organizationID: ID!
    key: ID!
    parentID: ID
  ): CollectionCreateResult! @canAccessCollection
}

###############################################################################
## End of Collections
###############################################################################

###############################################################################
### Payment
###############################################################################

type PaymentAccount {
  id: ID!
}

type PaymentAccountOnboardURL {
  url: String!
}

type PaymentAccountNotFound {
  organizationSlug: String!
}

type PaymentAccountExists {
  organizationSlug: String!
  paymentAccount: PaymentAccount!
}

union PaymentAccountCreateResult = PaymentAccount | PaymentAccountExists
union PaymentAccountOnboardURLResult =
    PaymentAccountOnboardURL
  | PaymentAccountNotFound

extend type Mutation {
  paymentAccountCreate(organizationSlug: String!): PaymentAccountCreateResult!
    @hasRole(role: ADMIN)
  paymentAccountOnboardURL(
    organizationSlug: String!
  ): PaymentAccountOnboardURLResult! @hasRole(role: ADMIN)
}

###############################################################################
### End of Payment
###############################################################################
