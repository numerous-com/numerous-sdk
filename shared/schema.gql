scalar Time
scalar Upload

directive @client on QUERY | FIELD
directive @trackOperation(eventName: String!) on FIELD_DEFINITION
directive @canAccessInvitation on FIELD_DEFINITION
directive @canManageApp on FIELD_DEFINITION

###############################################################################
### Auth
###############################################################################

directive @hasRole(role: AuthRole!) on FIELD_DEFINITION
directive @isMe on FIELD_DEFINITION

enum AuthRole {
  AUTHENTICATED
  ADMIN
  USER
}

###############################################################################
### Auth end
###############################################################################

###############################################################################
### User management
###############################################################################

enum Role {
  ADMIN
  USER
}

type OrganizationMembership {
  organization: Organization!
  role: Role!
  user: User!
}

type User {
  id: ID!
  fullName: String!
  memberships: [OrganizationMembership!]! @isMe
  email: String!
}

type Query {
  me: User! @hasRole(role: AUTHENTICATED)
}

###############################################################################
### End of user management
###############################################################################

###############################################################################
### Organization management
###############################################################################

type Organization {
  id: ID!
  name: String!
  slug: String!
  apps: [App!]!
  members: [OrganizationMembership!]! @hasRole(role: USER)
  pendingInvitations: [OrganizationInvitation!]! @hasRole(role: ADMIN)
  createdAt: Time!
}

type OrganizationInvitation {
  id: ID!
  email: String!
  organizationName: String!
  invitedAt: Time!
  role: Role!
}

type InvalidEmail {
  email: String!
}

type OrganizationMemberExists {
  email: String!
}

input NewOrganization {
  name: String!
  slug: String
}

type OrganizationNotFound {
  id: ID!
  slug: String!
}

type OrganizationRenameFailure {
  result: String!
}

union OrganizationRenameResult =
    Organization
  | OrganizationNotFound
  | OrganizationRenameFailure

union OrganizationQueryResult = Organization | OrganizationNotFound

type OrganizationSlugOccupied {
  slug: String!
}

type OrganizationSlugInvalid {
  slug: String!
}

union OrganizationCreateResult = Organization | OrganizationSlugOccupied | OrganizationSlugInvalid

extend type Query {
  organization(organizationSlug: String!): OrganizationQueryResult!
    @hasRole(role: USER)
  organizationInvitation(invitationId: ID!): OrganizationInvitationQueryResult
    @canAccessInvitation
}

type Mutation {
  organizationCreate(input: NewOrganization!): OrganizationCreateResult!
    @hasRole(role: AUTHENTICATED)
  organizationRename(
    organizationId: ID!
    name: String!
  ): OrganizationRenameResult! @hasRole(role: ADMIN)
}
###############################################################################
### End of organization management
###############################################################################

###############################################################################
### Organization invitation management
###############################################################################

input OrganizationInvitationInput {
  role: Role!
  email: String!
}

type OrganizationInvitationNotFound {
  id: ID!
}

type OrganizationInvitationExists {
  email: String!
}

union OrganizationInvitationQueryResult =
    OrganizationInvitation
  | OrganizationNotFound
  | OrganizationInvitationNotFound

union OrganizationInvitationCreateResult =
    OrganizationInvitation
  | OrganizationNotFound
  | InvalidEmail
  | OrganizationMemberExists
  | OrganizationInvitationExists

union OrganizationInvitationAcceptResult = Organization | OrganizationNotFound

type OrganizationInvitationDeleted {
  id: ID!
}

union OrganizationInvitationDeleteResult =
    OrganizationInvitationDeleted
  | OrganizationNotFound
  | OrganizationInvitationNotFound

extend type Mutation {
  organizationInvitationCreate(
    organizationId: ID!
    input: OrganizationInvitationInput
  ): OrganizationInvitationCreateResult! @hasRole(role: ADMIN)
  organizationInvitationAccept(
    invitationId: ID!
  ): OrganizationInvitationAcceptResult @canAccessInvitation
  organizationInvitationDelete(
    invitationId: ID!
  ): OrganizationInvitationDeleteResult @hasRole(role: ADMIN)
}

###############################################################################
### End of organization invitation management
###############################################################################



###############################################################################
### Tool management
###############################################################################

type Tool {
  id: ID!
  name: String!
  description: String
  user: User!
  publicUrl: String
  sharedUrl: String
  privateUrl: String
  createdAt: Time!
}

type PublicTool {
  developer: User!
  name: String!
  description: String
  pictureUrl: String
  publicUrl: String!
}

extend type Query {
  publicTools: [PublicTool!]
  tool(id: ID!): Tool!
  tools: [Tool!]! @hasRole(role: AUTHENTICATED)
}

input NewTool {
  userId: ID!
  manifest: String!
}

type ToolDeleteSuccess {
  result: String!
}

type ToolDeleteFailure {
  result: String!
}

union ToolDeleteResult = ToolDeleteSuccess | ToolDeleteFailure

extend type Mutation {
  toolCreate(input: NewTool!): Tool! @trackOperation(eventName: "App Create")
  toolPublish(id: ID!): Tool! @trackOperation(eventName: "App Publish")
  toolUnpublish(id: ID!): Tool! @trackOperation(eventName: "App Unpublish")
  toolDelete(id: ID!): ToolDeleteResult!
    @trackOperation(eventName: "App Delete")
}

###############################################################################
### End of tool management
###############################################################################
###############################################################################
### App management
###############################################################################

enum AppDeploymentStatus {
  PENDING
  RUNNING
  ERROR
  STOPPED
  UNKNOWN
}

type AppDeploymentVersion {
  id: ID!
  status: AppDeploymentStatus!
  proxyURL: String
}

type AppDeployment {
  id: ID!
  name: String!
  current: AppDeploymentVersion
}

type AppVersion {
  id: ID!
}

type App {
  id: ID!
  name: String!
  displayName: String!
  description: String!
  createdBy: User!
  createdAt: Time!
  defaultDeployment: AppDeployment
}

type AppVersionUploadURL {
  url: String!
}

input AppCreateInfo {
  name: String!
  displayName: String!
  description: String!
}

input AppDeployInput {
  secrets: [AppSecret!]
}

type AppBuildMessageEvent {
  message: String!
}

type AppDeploymentStatusEvent {
  status: AppDeploymentStatus
}

union AppDeployEvent = AppBuildMessageEvent | AppDeploymentStatusEvent

extend type Query {
  app(organizationSlug: String!, appName: String!): App @hasRole(role: USER)
}

extend type Mutation {
  appCreate(organizationSlug: String!, appData: AppCreateInfo!): App!
    @hasRole(role: USER)
  appVersionCreate(appID: ID!): AppVersion! @canManageApp
  appVersionUploadURL(appVersionID: ID!): AppVersionUploadURL! @canManageApp
  appDeploy(appVersionID: ID!, input: AppDeployInput): AppDeploymentVersion!
    @canManageApp
}

extend type Subscription {
  appDeployEvents(appDeploymentVersionID: ID!): AppDeployEvent!
}

###############################################################################
### End of App management
###############################################################################

###############################################################################
### Subscriptions
###############################################################################

directive @canAccessSubscriptionOffer on FIELD_DEFINITION

enum SubscriptionOfferStatus {
  ACCEPTED
  REJECTED
  PENDING
}

enum AppSubscriptionStatus {
  ACTIVE
  WITHDRAWN
}

type AppSubscription {
  id: ID!
  app: App!
  inboundOrganization: Organization!
  outboundOrganization: Organization!
  status: AppSubscriptionStatus!
}

type SubscriptionOffer {
  id: ID!
  email: String!
  app: App!
  offeringOrganization: Organization!
  status: SubscriptionOfferStatus!
}

input SubscriptionOfferInput {
  email: String!
  appName: String!
}

type SubscriptionOfferNotFound {
  id: ID!
}

type AppSubscriptionNotFound {
  id: ID!
}

union SubscriptionOfferCreateResult = SubscriptionOffer | InvalidEmail

union SubscriptionOfferResult = SubscriptionOffer | SubscriptionOfferNotFound

union SubscriptionOfferAcceptResult =
    AppSubscription
  | SubscriptionOfferNotFound

union AppSubscriptionResult = AppSubscription | AppSubscriptionNotFound

extend type Organization {
  outboundSubscriptionOffers: [SubscriptionOffer!]!
  outboundSubscriptions: [AppSubscription!]!
}

extend type App {
  subscription: AppSubscription
}

extend type Query {
  subscriptionOffer(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
}

extend type Mutation {
  subscriptionOfferCreate(
    input: SubscriptionOfferInput!
    organizationId: ID!
  ): SubscriptionOfferCreateResult! @hasRole(role: ADMIN)
  subscriptionOfferAccept(
    subscriptionOfferId: ID!
    organizationId: ID!
  ): SubscriptionOfferAcceptResult! @canAccessSubscriptionOffer
  subscriptionOfferReject(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
  subscriptionOfferWithdraw(subscriptionOfferId: ID!): SubscriptionOfferResult!
    @canAccessSubscriptionOffer
  subscriptionCancel(subscriptionId: ID!): AppSubscriptionResult!
    @hasRole(role: ADMIN)
}

###############################################################################
### End of Subscriptions
###############################################################################

###############################################################################
### Job management
###############################################################################

type Job {
  id: ID!
  status: String
  proxyUrl: String
  user: User!
  createdAt: Time!
}

type JobNotFound {
  id: ID!
}

type JobHeartbeatSuccess {
  id: ID!
}

type JobHeartbeatFailure {
  result: String!
}

union JobHeartbeatResult =
    JobHeartbeatSuccess
  | JobHeartbeatFailure
  | JobNotFound

type StopJobPayload {
  message: String!
}

enum ToolHashType {
  public
  shared
  private
}

extend type Query {
  job(toolHash: ID!, hashType: ToolHashType!): Job!
  jobsByTool(id: ID!): [Job!]!
}

extend type Mutation {
  jobStart(toolHash: ID!, hashType: ToolHashType!): Job!
    @trackOperation(eventName: "App Use/Requested from Proxy")
  jobStop(id: ID!): StopJobPayload!
  jobHeartbeat(id: ID!): JobHeartbeatResult!
}

###############################################################################
### End of job management
###############################################################################

###############################################################################
### Custom tool development
###############################################################################

interface ElementGraphParent {
  id: ID!
}

type ElementGraphContext {
  parent: ElementGraphParent
  affectedBy: [Element]!
  affects: [Element]!
}

interface Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type Container implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type SliderElement implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: Float!
  minValue: Float!
  maxValue: Float!
}

type HTMLElement implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  html: String!
}

type Button implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: String!
}

type TextField implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: String!
}

type NumberField implements Element {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  value: Float!
}

type ElementList implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
}

type ElementSelect implements Element & ElementGraphParent {
  id: ID!
  name: String!
  label: String!
  graphContext: ElementGraphContext!
  selectedOption: Element!
}

type ToolSession {
  id: ID!
  name: String!
  allElements: [Element!]!
  isActive: Boolean!
  clientID: String!
  title: String!
}

input ElementInput {
  elementID: ID!
  textValue: String
  numberValue: Float
  htmlValue: String
  sliderValue: Float
}

input ElementSelectInput {
  selectElementID: ID!
  selectedOptionID: ID!
}

input ListElementInput {
  listElementID: ID!
}

extend type Query {
  toolSession(id: ID!): ToolSession!
}

extend type Mutation {
  toolSessionCreate: ToolSession!
  elementUpdate(
    toolSessionId: ID!
    clientId: ID!
    element: ElementInput!
  ): Element!
  elementTrigger(
    toolSessionId: ID!
    clientId: ID!
    actionElementId: ID!
  ): Element!
  elementSelectionUpdate(
    clientId: ID!
    elementSelection: ElementSelectInput!
  ): Element!
  listElementAdd(clientId: ID!, listElement: ListElementInput): Element!
  listElementRemove(clientId: ID!, listItemID: ID!): Element!
}

type ToolSessionElementAdded {
  element: Element!
}

type ToolSessionElementRemoved {
  element: Element!
}

type ToolSessionElementUpdated {
  element: Element!
}

type ToolSessionActionTriggered {
  element: Button!
}

union ToolSessionEvent =
    ToolSessionElementAdded
  | ToolSessionElementRemoved
  | ToolSessionElementUpdated
  | ToolSessionActionTriggered

type Subscription {
  toolSessionEvent(toolSessionId: ID!, clientId: ID!): ToolSessionEvent!
}

###############################################################################
### End of custom tool development
###############################################################################

###############################################################################
### CLI Push command
###############################################################################

type buildConfiguration {
  buildId: ID!
}

type BuildEventSuccess {
  result: String!
}

type BuildEventFailure {
  result: String!
}

type BuildEventInfo {
  result: String!
}

union BuildEvent = BuildEventSuccess | BuildEventFailure | BuildEventInfo

input AppSecret {
  name: String!
  base64Value: String!
}

input BuildPushInput {
  secrets: [AppSecret!]
}

extend type Mutation {
  buildPush(file: Upload!, id: ID!, input: BuildPushInput): buildConfiguration!
    @trackOperation(eventName: "App Push")
}

extend type Subscription {
  buildEvents(buildId: ID!, appPath: String): BuildEvent!
}

extend type Subscription {
  deployEvents(toolID: ID!): BuildEvent!
}

###############################################################################
### End of CLI Push command
###############################################################################

###############################################################################
### CLI Logs command
###############################################################################

type LogMessage {
  time: Time!
  message: String!
}

extend type Subscription {
  logs(appId: ID!): LogMessage!
}

###############################################################################
### End of CLI Push command
###############################################################################
