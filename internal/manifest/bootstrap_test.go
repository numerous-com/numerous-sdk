package manifest

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"numerous.com/cli/internal/dir"
	"numerous.com/cli/internal/test"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func assertAllFilesExist(t *testing.T, paths []string) {
	t.Helper()

	for _, path := range paths {
		assert.FileExists(t, path)
	}
}

func TestBootstrapFiles(t *testing.T) {
	t.Run("adds expected lines to existing .gitignore", func(t *testing.T) {
		tmpDir := t.TempDir()
		toolID := "tool-id"
		m := Manifest{
			App: App{
				CoverImage: "conver_img.png",
			},
			Python: &Python{
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}
		initialGitIgnoreContent := "some/ignore/pattern\nanother-ignore-pattern"
		expectedGitIgnoreContent := initialGitIgnoreContent + "\n# added by numerous init\n\n.env\n.app_id.txt"
		gitignoreFilePath := filepath.Join(tmpDir, ".gitignore")
		test.WriteFile(t, gitignoreFilePath, []byte(initialGitIgnoreContent))

		err := m.BootstrapFiles(toolID, tmpDir)

		assert.NoError(t, err)
		actualGitIgnoreContent, err := os.ReadFile(gitignoreFilePath)
		if assert.NoError(t, err) {
			assert.Equal(t, expectedGitIgnoreContent, string(actualGitIgnoreContent))
		}
	})

	t.Run("writes manifest with expected excludes", func(t *testing.T) {
		tmpDir := t.TempDir()
		toolID := "tool-id"
		m := Manifest{
			App: App{
				CoverImage: "conver_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
				Library:          LibraryMarimo,
			},
		}

		bootErr := m.BootstrapFiles(toolID, tmpDir)
		loaded, manifestErr := Load(tmpDir + "/" + ManifestFileName)

		assert.NoError(t, bootErr)
		assert.NoError(t, manifestErr)
		expectedExclude := []string{"*venv", "venv*", ".git", ".env"}
		assert.Equal(t, expectedExclude, loaded.Exclude)
	})

	t.Run("given app id then it writes .app_id.txt", func(t *testing.T) {
		tmpDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "conver_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}
		appID := "some app id"

		bootErr := m.BootstrapFiles(appID, tmpDir)

		appIDFilePath := filepath.Join(tmpDir, dir.AppIDFileName)
		if assert.NoError(t, bootErr) {
			assert.FileExists(t, appIDFilePath)
			data, err := os.ReadFile(appIDFilePath)
			if assert.NoError(t, err) {
				assert.Equal(t, appID, string(data))
			}
		}
	})

	t.Run("given no app id then it does not write .app_id.txt", func(t *testing.T) {
		tmpDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "conver_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}

		err := m.BootstrapFiles("", tmpDir)

		appIDFilePath := filepath.Join(tmpDir, dir.AppIDFileName)
		if assert.NoError(t, err) {
			assert.NoFileExists(t, appIDFilePath)
		}
	})
}

const expectedNumerousApp string = `"""An autogenerated example Numerous App Engine app."""

from numerous import action, app, slider

@app
class MyApp:
	count: float
	step: float = slider(min_value=0, max_value=10)

	@action
	def increment(self) -> None:
		self.count += self.step


appdef = MyApp
`

const expectedPanelApp string = `"""An autogenerated example Panel app."""

import panel as pn

pn.template.MaterialTemplate(
    site="Panel",
    title="Hello world app",
    main=[pn.pane.Markdown("# Hello, world!")],
).servable()
`

func TestBootstrapFilesPythonApp(t *testing.T) {
	t.Run("all files exist", func(t *testing.T) {
		tempDir := t.TempDir()
		require.NoError(t, os.Chdir(tempDir))
		lib, err := GetLibraryByKey("streamlit")
		require.NoError(t, err)
		m := Manifest{
			App: App{
				CoverImage: "cover_image.png",
			},
			Python: &Python{
				Library:          lib,
				AppFile:          "app.py",
				RequirementsFile: "requirements.txt",
			},
		}
		expectedFiles := []string{
			".gitignore",
			ManifestFileName,
			m.Python.AppFile,
			m.Python.RequirementsFile,
			m.CoverImage,
		}

		err = m.BootstrapFiles("some-id", tempDir)

		if assert.NoError(t, err) {
			assertAllFilesExist(t, expectedFiles)
		}
	})

	t.Run("requirements", func(t *testing.T) {
		var (
			dummyRequirementsWithoutNewLine = strings.Join([]string{"some", "different", "dependencies=2.0.0"}, "\n")
			dummyRequirementsWithNewLine    = dummyRequirementsWithoutNewLine + "\n"
		)

		for _, tc := range []struct {
			name                 string
			library              Library
			initialRequirements  string
			expectedRequirements string
		}{
			{
				name:                 "plotly-dash without initial requirements",
				library:              LibraryPlotlyDash,
				initialRequirements:  "",
				expectedRequirements: "dash\ngunicorn\n",
			},
			{
				name:                 "streamlit without initial requirements",
				library:              LibraryStreamlit,
				initialRequirements:  "",
				expectedRequirements: "streamlit\n",
			},
			{
				name:                 "marimo without initial requirements",
				library:              LibraryMarimo,
				initialRequirements:  "",
				expectedRequirements: "marimo\n",
			},
			{
				name:                 "numerous without initial requirements",
				library:              LibraryNumerous,
				initialRequirements:  "",
				expectedRequirements: "numerous\n",
			},
			{
				name:                 "marimo with initial requirements with newline appends at end",
				library:              LibraryMarimo,
				initialRequirements:  dummyRequirementsWithNewLine,
				expectedRequirements: dummyRequirementsWithNewLine + "marimo\n",
			},
			{
				name:                 "marimo with initial requirements without newline appends at end",
				library:              LibraryMarimo,
				initialRequirements:  dummyRequirementsWithoutNewLine,
				expectedRequirements: dummyRequirementsWithNewLine + "marimo\n",
			},
			{
				name:                 "marimo with initial requirements and library is part of requirements, nothing changes",
				library:              LibraryMarimo,
				initialRequirements:  "marimo\n" + dummyRequirementsWithNewLine,
				expectedRequirements: "marimo\n" + dummyRequirementsWithNewLine,
			},
		} {
			t.Run(tc.name, func(t *testing.T) {
				tempDir := t.TempDir()
				require.NoError(t, os.Chdir(tempDir))
				m := Manifest{
					App: App{
						CoverImage: "cover_image.png",
					},
					Python: &Python{
						Library:          tc.library,
						AppFile:          "app.py",
						RequirementsFile: "requirements.txt",
					},
				}
				if tc.initialRequirements != "" {
					err := os.WriteFile(m.Python.RequirementsFile, []byte(tc.initialRequirements), 0o644)
					require.NoError(t, err)
				}

				err := m.BootstrapFiles("some-id", tempDir)

				require.NoError(t, err)
				actualRequirements, err := os.ReadFile(m.Python.RequirementsFile)
				require.NoError(t, err)
				assert.Equal(t, tc.expectedRequirements, string(actualRequirements))
			})
		}
	})

	t.Run("bootstraps app file", func(t *testing.T) {
		for _, tc := range []struct {
			name            string
			library         Library
			expectedAppFile string
		}{
			{
				name:            "numerous",
				library:         LibraryNumerous,
				expectedAppFile: expectedNumerousApp,
			},
			{
				name:            "streamlit",
				library:         LibraryStreamlit,
				expectedAppFile: "",
			},
			{
				name:            "dash",
				library:         LibraryPlotlyDash,
				expectedAppFile: "",
			},
			{
				name:            "marimo",
				library:         LibraryMarimo,
				expectedAppFile: "",
			},
			{
				name:            "panel",
				library:         LibraryPanel,
				expectedAppFile: expectedPanelApp,
			},
		} {
			t.Run(tc.name, func(t *testing.T) {
				require.NoError(t, os.Chdir(t.TempDir()))
				m := Manifest{
					App: App{
						CoverImage: "cover_image.png",
					},
					Python: &Python{
						Library:          tc.library,
						AppFile:          "app.py",
						RequirementsFile: "requirements.txt",
					},
				}
				tempDir, err := os.Getwd()
				require.NoError(t, err)

				err = m.BootstrapFiles("tool id", tempDir)

				require.NoError(t, err)
				appContent, err := os.ReadFile("app.py")
				require.NoError(t, err)
				assert.Equal(t, tc.expectedAppFile, string(appContent))
			})
		}
	})
}
