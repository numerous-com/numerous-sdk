package manifest

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"numerous.com/cli/internal/dir"
	"numerous.com/cli/internal/test"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func assertAllFilesExist(t *testing.T, paths []string) {
	t.Helper()

	for _, path := range paths {
		assert.FileExists(t, path)
	}
}

func TestBootstrapFiles(t *testing.T) {
	t.Run("adds expected lines to existing .gitignore", func(t *testing.T) {
		tmpDir := t.TempDir()
		toolID := "tool-id"
		m := Manifest{
			App: App{
				CoverImage: "cover_img.png",
			},
			Python: &Python{
				Library:          LibraryMarimo,
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}
		initialGitIgnoreContent := "some/ignore/pattern\nanother-ignore-pattern"
		expectedGitIgnoreContent := initialGitIgnoreContent + "\n# added by numerous init\n\n.env\n.app_id.txt"
		gitignoreFilePath := filepath.Join(tmpDir, ".gitignore")
		test.WriteFile(t, gitignoreFilePath, []byte(initialGitIgnoreContent))

		err := m.BootstrapFiles(toolID, tmpDir)

		assert.NoError(t, err)
		actualGitIgnoreContent, err := os.ReadFile(gitignoreFilePath)
		if assert.NoError(t, err) {
			assert.Equal(t, expectedGitIgnoreContent, string(actualGitIgnoreContent))
		}
	})

	t.Run("writes manifest with expected excludes", func(t *testing.T) {
		tmpDir := t.TempDir()
		toolID := "tool-id"
		m := Manifest{
			App: App{
				CoverImage: "cover_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
				Library:          LibraryMarimo,
			},
		}

		bootErr := m.BootstrapFiles(toolID, tmpDir)
		loaded, manifestErr := Load(tmpDir + "/" + ManifestFileName)

		assert.NoError(t, bootErr)
		assert.NoError(t, manifestErr)
		expectedExclude := []string{"*venv", "venv*", ".git", ".env"}
		assert.Equal(t, expectedExclude, loaded.Exclude)
	})

	t.Run("given app id then it writes .app_id.txt", func(t *testing.T) {
		tmpDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "cover_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				Library:          LibraryMarimo,
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}
		appID := "some app id"

		bootErr := m.BootstrapFiles(appID, tmpDir)

		appIDFilePath := filepath.Join(tmpDir, dir.AppIDFileName)
		if assert.NoError(t, bootErr) {
			assert.FileExists(t, appIDFilePath)
			data, err := os.ReadFile(appIDFilePath)
			if assert.NoError(t, err) {
				assert.Equal(t, appID, string(data))
			}
		}
	})

	t.Run("given no app id then it does not write .app_id.txt", func(t *testing.T) {
		tmpDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "cover_img.png",
				Exclude:    []string{"*venv", "venv*", ".git", ".env"},
			},
			Python: &Python{
				Library:          LibraryMarimo,
				RequirementsFile: "requirements.txt",
				AppFile:          "app.py",
			},
		}

		err := m.BootstrapFiles("", tmpDir)

		appIDFilePath := filepath.Join(tmpDir, dir.AppIDFileName)
		if assert.NoError(t, err) {
			assert.NoFileExists(t, appIDFilePath)
		}
	})
}

const expectedNumerousApp string = `"""An autogenerated example Numerous App Engine app."""

from numerous import action, app, slider

@app
class MyApp:
	count: float
	step: float = slider(min_value=0, max_value=10)

	@action
	def increment(self) -> None:
		self.count += self.step


appdef = MyApp
`

const expectedPanelApp string = `"""An autogenerated example Panel app."""

import panel as pn

pn.template.MaterialTemplate(
    site="Panel",
    title="Hello world app",
    main=[pn.pane.Markdown("# Hello, world!")],
).servable()
`

func TestBootstrapFilesPythonApp(t *testing.T) {
	t.Run("all files exist", func(t *testing.T) {
		appDir := t.TempDir()
		lib, err := GetLibraryByKey("streamlit")
		require.NoError(t, err)
		m := Manifest{
			App: App{
				CoverImage: "cover_image.png",
			},
			Python: &Python{
				Library:          lib,
				AppFile:          "app.py",
				RequirementsFile: "requirements.txt",
			},
		}
		expectedFiles := []string{
			filepath.Join(appDir, ".gitignore"),
			filepath.Join(appDir, ManifestFileName),
			filepath.Join(appDir, m.Python.AppFile),
			filepath.Join(appDir, m.Python.RequirementsFile),
			filepath.Join(appDir, m.CoverImage),
		}

		err = m.BootstrapFiles("some-id", appDir)

		if assert.NoError(t, err) {
			assertAllFilesExist(t, expectedFiles)
		}
	})

	t.Run("requirements", func(t *testing.T) {
		var (
			dummyRequirementsWithoutNewLine = strings.Join([]string{"some", "different", "dependencies=2.0.0"}, "\n")
			dummyRequirementsWithNewLine    = dummyRequirementsWithoutNewLine + "\n"
		)

		for _, tc := range []struct {
			name                 string
			library              Library
			initialRequirements  string
			expectedRequirements string
		}{
			{
				name:                 "plotly-dash without initial requirements",
				library:              LibraryPlotlyDash,
				initialRequirements:  "",
				expectedRequirements: "dash\ngunicorn\n",
			},
			{
				name:                 "streamlit without initial requirements",
				library:              LibraryStreamlit,
				initialRequirements:  "",
				expectedRequirements: "streamlit\n",
			},
			{
				name:                 "marimo without initial requirements",
				library:              LibraryMarimo,
				initialRequirements:  "",
				expectedRequirements: "marimo\n",
			},
			{
				name:                 "numerous without initial requirements",
				library:              LibraryNumerous,
				initialRequirements:  "",
				expectedRequirements: "numerous\n",
			},
			{
				name:                 "marimo with initial requirements with newline appends at end",
				library:              LibraryMarimo,
				initialRequirements:  dummyRequirementsWithNewLine,
				expectedRequirements: dummyRequirementsWithNewLine + "marimo\n",
			},
			{
				name:                 "marimo with initial requirements without newline appends at end",
				library:              LibraryMarimo,
				initialRequirements:  dummyRequirementsWithoutNewLine,
				expectedRequirements: dummyRequirementsWithNewLine + "marimo\n",
			},
			{
				name:                 "marimo with initial requirements and library is part of requirements, nothing changes",
				library:              LibraryMarimo,
				initialRequirements:  "marimo\n" + dummyRequirementsWithNewLine,
				expectedRequirements: "marimo\n" + dummyRequirementsWithNewLine,
			},
		} {
			t.Run(tc.name, func(t *testing.T) {
				appDir := t.TempDir()
				m := Manifest{
					App: App{
						CoverImage: "cover_image.png",
					},
					Python: &Python{
						Library:          tc.library,
						AppFile:          "app.py",
						RequirementsFile: "requirements.txt",
					},
				}
				requiremenstPath := filepath.Join(appDir, m.Python.RequirementsFile)
				if tc.initialRequirements != "" {
					test.WriteFile(t, requiremenstPath, []byte(tc.initialRequirements))
				}

				err := m.BootstrapFiles("some-id", appDir)

				assert.NoError(t, err)
				test.AssertFileContent(t, requiremenstPath, []byte(tc.expectedRequirements))
			})
		}
	})

	t.Run("bootstraps app file", func(t *testing.T) {
		for _, tc := range []struct {
			name            string
			library         Library
			expectedAppFile string
		}{
			{
				name:            "numerous",
				library:         LibraryNumerous,
				expectedAppFile: expectedNumerousApp,
			},
			{
				name:            "streamlit",
				library:         LibraryStreamlit,
				expectedAppFile: "",
			},
			{
				name:            "dash",
				library:         LibraryPlotlyDash,
				expectedAppFile: "",
			},
			{
				name:            "marimo",
				library:         LibraryMarimo,
				expectedAppFile: "",
			},
			{
				name:            "panel",
				library:         LibraryPanel,
				expectedAppFile: expectedPanelApp,
			},
		} {
			t.Run(tc.name, func(t *testing.T) {
				appDir := t.TempDir()
				m := Manifest{
					App: App{
						CoverImage: "cover_image.png",
					},
					Python: &Python{
						Library:          tc.library,
						AppFile:          "app.py",
						RequirementsFile: "requirements.txt",
					},
				}

				err := m.BootstrapFiles("tool id", appDir)

				assert.NoError(t, err)
				test.AssertFileContent(t, filepath.Join(appDir, "app.py"), []byte(tc.expectedAppFile))
			})
		}
	})
}

func TestBootstrapDockerApp(t *testing.T) {
	t.Run("given no pre-existing dockerfile it bootstraps example docker app", func(t *testing.T) {
		appDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "cover_image.png",
			},
			Docker: &Docker{
				Dockerfile: "Dockerfile",
				Context:    ".",
			},
		}

		err := m.BootstrapFiles("", appDir)

		assert.NoError(t, err)
		test.AssertFileContent(t, filepath.Join(appDir, "Dockerfile"), []byte(dockerExampleDockerfile))
		test.AssertFileContent(t, filepath.Join(appDir, "app.py"), []byte(dockerExampleAppPy))
		test.AssertFileContent(t, filepath.Join(appDir, "requirements.txt"), []byte(dockerExampleRequirementsTxt))
	})

	t.Run("given pre-existing dockerfile it does not bootstrap docker example files", func(t *testing.T) {
		dockerfileContent := []byte("FROM hello-world")
		appDir := t.TempDir()
		m := Manifest{
			App: App{
				CoverImage: "cover_image.png",
			},
			Docker: &Docker{
				Dockerfile: "Dockerfile",
				Context:    ".",
			},
		}
		dockerfilePath := filepath.Join(appDir, "Dockerfile")
		test.WriteFile(t, dockerfilePath, dockerfileContent)

		err := m.BootstrapFiles("", appDir)

		assert.NoError(t, err)
		test.AssertFileContent(t, dockerfilePath, dockerfileContent)
		assert.NoFileExists(t, filepath.Join(appDir, "app.py"))
		assert.NoFileExists(t, filepath.Join(appDir, "requirements.txt"))
	})

	t.Run("given pre-existing extra files it does not overwrite them", func(t *testing.T) {
		appDir := t.TempDir()

		appFilePath := filepath.Join(appDir, "app.py")
		appContent := []byte("print(\"hello, world!\")")
		test.WriteFile(t, appFilePath, appContent)

		requirementsFilePath := filepath.Join(appDir, "requirements.txt")
		requirementsContent := []byte("fastapi\nnumpy\n")
		test.WriteFile(t, requirementsFilePath, requirementsContent)

		m := Manifest{
			App: App{
				CoverImage: "cover_image.png",
			},
			Docker: &Docker{
				Dockerfile: "Dockerfile",
				Context:    ".",
			},
		}

		err := m.BootstrapFiles("", appDir)

		assert.NoError(t, err)
		test.AssertFileContent(t, appFilePath, appContent)
		test.AssertFileContent(t, requirementsFilePath, requirementsContent)
	})
}
